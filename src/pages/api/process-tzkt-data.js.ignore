import axios from 'axios';
import fs from 'fs';
import path from 'path';

// Define the path to the cache file
// const cacheFilePath = path.resolve('./tzktDataCache.json');
const cacheFilePath = path.join(process.cwd(), 'public', 'tzktDataCache.json');

export default async function handler(req, res) {
  const cacheDuration = 3600000; // 1 hour in milliseconds

  try {
    // Check if cache file exists and read it
    if (fs.existsSync(cacheFilePath)) {
      const cacheFile = fs.readFileSync(cacheFilePath);
      const cache = JSON.parse(cacheFile);

      const now = new Date().getTime();
      if (now - cache.timestamp < cacheDuration) {
        // Cache is still valid, return cached data
        return res.status(200).json(cache.data);
      }
    }

    // Define the base URL for the API call
    const baseUrl = "https://api.tzkt.io/v1/accounts/KT1CeFqjJRJPNVvhvznQrWfHad2jCiDZ6Lyj/operations?sort.desc=level&sender=KT1CeFqjJRJPNVvhvznQrWfHad2jCiDZ6Lyj&entrypoint.null";
    let lastId = null; // Initialize lastId for pagination
    let allData = []; // Array to collect all pages of data

    try {
      let hasMoreData = true; // Flag to control the loop

      while (hasMoreData) {
        // Construct the URL with pagination if lastId is available
        const urlWithPagination = lastId ? `${baseUrl}&lastId=${lastId}` : baseUrl;
        const response = await axios.get(urlWithPagination);
        const data = response.data;

        if (data.length > 0) {
          // Process and add the fetched data to the allData array
          const processedData = data.map(item => ({
            timestamp: item.timestamp.split('T')[0],
            to: item.target?.address || '',
            amount: parseFloat(item.amount) / 1e6,
            hash: item.hash,
          }));
          allData = allData.concat(processedData);

          // Update lastId for the next iteration
          lastId = data[data.length - 1].id;
        } else {
          // No more data to fetch
          hasMoreData = false;
        }
      }

      // Cache the new data with a timestamp
      const cache = {
        timestamp: new Date().getTime(),
        data: allData
      };
      fs.writeFileSync(cacheFilePath, JSON.stringify(cache));

      res.status(200).json(allData);
    } catch (error) {
      console.error('Error:', error);
      res.status(500).json({ error: 'An error occurred' });
    }
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'An error occurred' });
  }
}